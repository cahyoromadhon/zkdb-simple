import { Bool, Character, CircuitString, Field, InferProvable, Int64, MerkleMapWitness, PrivateKey, PublicKey, Sign, Signature, Struct, UInt32, UInt64 } from 'o1js';
import { TMerkleNodeJson } from './types/merkle-tree';
export declare const PROVABLE_TYPE_MAP: {
    readonly CircuitString: typeof CircuitString;
    readonly UInt32: typeof UInt32;
    readonly UInt64: typeof UInt64;
    readonly Bool: typeof import("o1js/dist/node/lib/provable/bool").Bool & ((x: boolean | import("o1js/dist/node/lib/provable/core/fieldvar").FieldVar | import("o1js/dist/node/lib/provable/bool").Bool) => import("o1js/dist/node/lib/provable/bool").Bool);
    readonly Sign: typeof Sign;
    readonly Character: typeof Character;
    readonly Int64: typeof Int64;
    readonly Field: typeof import("o1js/dist/node/lib/provable/field").Field & ((x: string | number | bigint | import("o1js/dist/node/lib/provable/core/fieldvar").FieldConst | import("o1js/dist/node/lib/provable/core/fieldvar").FieldVar | import("o1js/dist/node/lib/provable/field").Field) => import("o1js/dist/node/lib/provable/field").Field);
    readonly PrivateKey: typeof PrivateKey;
    readonly PublicKey: typeof PublicKey;
    readonly Signature: typeof Signature;
    readonly MerkleMapWitness: typeof MerkleMapWitness;
};
export declare const PROVABLE_VALID_TYPE: string[];
export type TProvableType = (typeof PROVABLE_TYPE_MAP)[keyof typeof PROVABLE_TYPE_MAP];
export type TProvableTypeString = keyof typeof PROVABLE_TYPE_MAP;
export type TSchemaQueryMap<T> = {
    [K in keyof T]: T[K] extends typeof UInt64 ? bigint : T[K] extends typeof Int64 ? bigint : T[K] extends typeof Sign ? boolean : T[K] extends typeof Bool ? boolean : T[K] extends typeof UInt32 ? number : T[K] extends MerkleMapWitness ? TMerkleNodeJson[] : string;
};
/** Map of Provable types to their corresponding JavaScript types. */
type TProvableToSerializedMap = {
    CircuitString: string;
    UInt32: number;
    Int64: bigint;
    UInt64: bigint;
    Bool: boolean;
    PrivateKey: string;
    PublicKey: string;
    Signature: string;
    Character: string;
    Sign: boolean;
    Field: string;
    MerkleMapWitness: TMerkleNodeJson[];
};
/**
 * Represents all possible serialized values that can be stored in a provable
 * field. This is a union type of all values in the TProvableToSerializedMap.
 */
export type TSerializedValue = TProvableToSerializedMap[keyof TProvableToSerializedMap];
/**
 * Represents a field with a name, kind, and the actual value.
 * Rendered as a union of all possible field types.
 * ```ts
 * type TSchemaSerializedField = {
 *     name: string;
 *     kind: "CircuitString";
 *     value: string;
 * } | {
 *     name: string;
 *     kind: "UInt32";
 *     value: bigint;
 * } | {
 * } | ... 7 more ... | {
 *     ...;
 * }
 * ```
 */
export type TSchemaSerializedField = {
    [K in TProvableTypeString]: {
        name: string;
        kind: K;
        value: TProvableToSerializedMap[K];
    };
}[TProvableTypeString];
export type TSchemaSerializedFieldDefinition = Omit<TSchemaSerializedField, 'value'>;
export interface ISchemaExtend {
    serialize(): TSchemaSerializedField[];
    hash(): Field;
}
export interface ISchemaStatic<A> {
    innerStructure: TSchemaQueryMap<A>;
    deserialize(doc: TSchemaSerializedField[]): InstanceType<TSchemaExtendable<A>>;
    definition(): TSchemaSerializedFieldDefinition[];
}
export type TSchemaExtendable<A, T extends InferProvable<A> = InferProvable<A> & ISchemaExtend> = Struct<InferProvable<A>> & (new (..._args: any[]) => T) & ISchemaStatic<A>;
export type TProvableMapped<T extends TSchemaSerializedFieldDefinition[]> = {
    [Property in T[number]['name']]?: (typeof PROVABLE_TYPE_MAP)[TProvableTypeString];
};
export declare class Schema {
    static create<A>(type: A): TSchemaExtendable<A>;
    static fromEntries(record: string[][]): TSchemaExtendable<TProvableMapped<TSchemaSerializedFieldDefinition[]>, {
        [x: string]: import("o1js/dist/node/lib/provable/field").Field | CircuitString | UInt32 | UInt64 | import("o1js/dist/node/lib/provable/bool").Bool | Sign | Character | Int64 | PrivateKey | PublicKey | Signature | MerkleMapWitness | undefined;
    } & ISchemaExtend>;
    static fromSchema(schema: TSchemaSerializedFieldDefinition[]): TSchemaExtendable<TProvableMapped<TSchemaSerializedFieldDefinition[]>, {
        [x: string]: import("o1js/dist/node/lib/provable/field").Field | CircuitString | UInt32 | UInt64 | import("o1js/dist/node/lib/provable/bool").Bool | Sign | Character | Int64 | PrivateKey | PublicKey | Signature | MerkleMapWitness | undefined;
    } & ISchemaExtend>;
}
export {};
